<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Format String on hkbin的小博客~</title><link>https://hkbinbin.github.io/tags/format-string/</link><description>Recent content in Format String on hkbin的小博客~</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Mon, 28 Apr 2025 22:06:57 +0800</lastBuildDate><atom:link href="https://hkbinbin.github.io/tags/format-string/index.xml" rel="self" type="application/rss+xml"/><item><title>Blind Pwn的一些思考</title><link>https://hkbinbin.github.io/p/blind-pwn%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</link><pubDate>Mon, 28 Apr 2025 22:06:57 +0800</pubDate><guid>https://hkbinbin.github.io/p/blind-pwn%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</guid><description>&lt;h1 id="blind-pwn的一些思考">&lt;a href="#blind-pwn%e7%9a%84%e4%b8%80%e4%ba%9b%e6%80%9d%e8%80%83" class="header-anchor">&lt;/a>Blind Pwn的一些思考
&lt;/h1>&lt;h2 id="闲聊">&lt;a href="#%e9%97%b2%e8%81%8a" class="header-anchor">&lt;/a>闲聊
&lt;/h2>&lt;p>2025年长城杯决赛渗透出现了一个pwn服务，然而并没有附件，经过测试发现是format string类型的漏洞，不禁想起Blind Pwn，但是打的又少，导致浪费了好几个小时…&lt;/p>
&lt;p>期间对利用的一些思考，借此机会记录一下&lt;/p>
&lt;h2 id="问题的关键">&lt;a href="#%e9%97%ae%e9%a2%98%e7%9a%84%e5%85%b3%e9%94%ae" class="header-anchor">&lt;/a>问题的关键
&lt;/h2>&lt;p>问题的关键是无任何有效信息，即使栈溢出也不知道应该跳转到哪里&lt;/p>
&lt;p>对此有两种思路&lt;/p>
&lt;ol>
&lt;li>爆破地址观察程序相应情况，来判断是否进入了某些函数（如输出函数，main函数等），这种对应的手法应该是BROP（利用条件为纯栈溢出，NO PIE）&lt;/li>
&lt;li>通过fmt漏洞直接leak elf数据（%s-%p等来确认），这种手法利用条件为format string漏洞&lt;/li>
&lt;/ol>
&lt;p>无论是哪种思路，第一大步的目的就是寻找到puts/printf/write这些函数，进一步泄露整个elf，当这一步完成的时候，就和普通pwn没有区别了&lt;/p>
&lt;h2 id="brop">&lt;a href="#brop" class="header-anchor">&lt;/a>BROP
&lt;/h2>&lt;p>这种手法需要大量尝试/爆破，利用条件为栈溢出/NO PIE，在没有PIE保护的情况下，我们可以知道程序的elf base，然后在挟持执行流的时候，将返回地址遍历挟持整个elf代码段的每个地址，寻找对应gadgets&lt;/p>
&lt;h3 id="stopping-gadgets">&lt;a href="#stopping-gadgets" class="header-anchor">&lt;/a>Stopping gadgets
&lt;/h3>&lt;p>Stopping gadgets指的是让程序卡住但不崩溃的gadget，比如main/_start，这几个函数的地址，它会让程序重启，但不会断开socket链接，通过这一现象就可以判断是否拿到Stopping gadgets。&lt;/p>
&lt;p>Stopping gadgets会为下一步拿到其他gadgets作为一个依靠&lt;/p>
&lt;h3 id="register-gadgets">&lt;a href="#register-gadgets" class="header-anchor">&lt;/a>register gadgets
&lt;/h3>&lt;p>下一步寻找register gadgets，这一步不确定性挺大的&lt;/p>
&lt;p>如需要寻找&lt;code>pop rdi; ret&lt;/code> 这个gadget，将payload设置为&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">flat&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">padding&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pop_rdi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Stopping&lt;/span> &lt;span class="n">gadget&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个payload会将设pop_rdi的地址满足它是一个&lt;code>pop xxx ; ret&lt;/code> 结构，然后不能影响后面进入Stopping gadget&lt;/p>
&lt;p>所以依赖这个Stopping gadget，我们可以根据程序如果挂了，那就这个地址不满足，否则应该是满足这个结构的&lt;/p>
&lt;h3 id="leak-functions">&lt;a href="#leak-functions" class="header-anchor">&lt;/a>leak functions
&lt;/h3>&lt;p>接下来下一步需要寻找能够输出的函数，比如&lt;code>puts&lt;/code> /&lt;code>printf&lt;/code> /&lt;code>write&lt;/code> 这几个，这一步同样依赖于上面的register gadgets以及Stopping gadgets&lt;/p>
&lt;p>构造payload如&lt;/p>
&lt;p>&lt;code>puts&lt;/code> /&lt;code>printf&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">flat&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">padding&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pop_rdi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">xxx&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">puts_addr&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Stopping&lt;/span> &lt;span class="n">gadget&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里的puts_addr需要遍历整个代码段，pop_rdi有多种情况，取决于得到满足的register gadgets数量，所以这一步需要爆破的更多&lt;/p>
&lt;p>这里xxx填什么呢，我们都知道ELF程序有个header，里面的值是\x7fELF开头的&lt;/p>
&lt;p>所以把xxx填为&lt;code>0x400000&lt;/code> 即可&lt;/p>
&lt;p>如果成功找到，那么就会输出\x7fELF&lt;/p>
&lt;p>&lt;code>write&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">flat&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">padding&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pop_rdi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pop_rsi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">xxx&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pop_rdx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x50&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">puts_addr&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Stopping&lt;/span> &lt;span class="n">gadget&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用write输出就会更加复杂，因为需要爆破的次数变成了puts_addr可能值 * register gadgets数量^3&lt;/p>
&lt;p>理论可行，但实际上估计很难爆出来&lt;/p>
&lt;h3 id="leak-elf">&lt;a href="#leak-elf" class="header-anchor">&lt;/a>Leak ELF
&lt;/h3>&lt;p>当上面的三种gadgets全部找到之后，我们就能确定一整条leak链了，通过挟持执行流主动调用这条利用链就可以把整个ELF dump下来，后面就不是什么难事了&lt;/p>
&lt;h2 id="format-string-in-blind-pwn">&lt;a href="#format-string-in-blind-pwn" class="header-anchor">&lt;/a>Format String in Blind Pwn
&lt;/h2>&lt;p>这种情况下会相对于BROP更加简单(吗?)&lt;/p>
&lt;p>fmt漏洞又分为栈上和堆上两种&lt;/p>
&lt;p>对于栈上自然是好做的，直接就可以往栈里布置elf指针，然后通过&lt;code>%s&lt;/code> 来泄露对应地址，虽然&lt;code>\x00&lt;/code> 无法获知，但是我们可以通过无输出来判断&lt;/p>
&lt;p>堆上其实也好做，区别在于需要先通过&lt;code>%n&lt;/code> 链子来对指针进行修改，这里需要回忆一下堆上fmt pwn是怎么做的，最通用的做法就是利用栈上环境变量的指针，它的结构长这样：&lt;/p>
&lt;p>&lt;code>A: B→C(&amp;quot;/home/hkbin/pwn&amp;quot;)&lt;/code>&lt;/p>
&lt;p>在A地址上，存在B指针，指向C，C的内容是环境变量&lt;/p>
&lt;p>此时通过&lt;code>%n&lt;/code> 系列的fmt，修改C的值，让它一步步成为一个栈地址&lt;/p>
&lt;p>此时就变成这样的链子&lt;/p>
&lt;p>&lt;code>A: B-&amp;gt;C-&amp;gt;D(xxx)&lt;/code>&lt;/p>
&lt;p>后续即可配合&lt;code>A: B-&amp;gt;C&lt;/code> 以及&lt;code>B: C-&amp;gt;D&lt;/code> 这两条链子实现任意地址读写了&lt;/p>
&lt;p>对于Blind Pwn同样也可以这样做，创造了自己的&lt;code>B: C-&amp;gt;D&lt;/code> 链子之后就可以去leak ELF了&lt;/p>
&lt;p>但是缺点也很明显，构造&lt;code>B: C-&amp;gt;D&lt;/code> 链子的成本比较高，需要很长的payload，并且往往需要使用&lt;code>%lln&lt;/code> ，1byte1byte地写入，速度比较慢，也比较复杂&lt;/p>
&lt;h2 id="回到闲聊">&lt;a href="#%e5%9b%9e%e5%88%b0%e9%97%b2%e8%81%8a" class="header-anchor">&lt;/a>回到闲聊
&lt;/h2>&lt;p>长城杯题目环境是栈上的fmt漏洞，那为啥很难打呢，因为他会&lt;code>\x00&lt;/code> 截断&lt;/p>
&lt;p>在这种情况下我们无法随意地插入例如&lt;code>0x400000&lt;/code> 这样的地址，这会导致一些对齐后的函数没法完好地dump下来，并且输入长度也有限，想构造类似堆上fmt的链子也无法完成(&lt;/p>
&lt;p>😭 😭&lt;/p></description></item></channel></rss>